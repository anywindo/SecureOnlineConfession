(() => {
    const state = {
        session: null,
        debugMode: false,
        threads: [],
        messagesByThread: {},
        activeThreadId: null,
        activeThreadMeta: null,
        loadingThreads: false,
    };

    const els = {
        welcome: document.getElementById('user-welcome'),
        loginBtn: document.getElementById('login-btn'),
        usernameDisplay: document.getElementById('username-display'),
        userRoleDisplay: document.getElementById('user-role-display'),
        userNameDisplay: document.getElementById('user-name-display-main'),
        roleDescription: document.getElementById('role-description'),
        confessSection: document.getElementById('confess-section'),
        statsSection: document.getElementById('stats-section'),
        statTotal: document.getElementById('stat-total'),
        statAwaiting: document.getElementById('stat-awaiting'),
        statReplied: document.getElementById('stat-replied'),
        confessionList: document.getElementById('confession-list'),
        confessForm: document.getElementById('confess-form'),
        priestSelect: document.getElementById('priest-select'),
        debugToggle: document.getElementById('debug-toggle'),
        threadList: document.getElementById('thread-list'),
        threadEmpty: document.getElementById('thread-empty'),
        refreshBtn: document.getElementById('refresh-threads'),
        chatMessages: document.getElementById('chat-messages'),
        messageForm: document.getElementById('message-form'),
        messageTextarea: document.querySelector('#message-form textarea'),
        resolveCheckbox: document.querySelector('#message-form input[name="resolve"]'),
        activePartner: document.getElementById('active-partner'),
        activeSubject: document.getElementById('active-subject'),
        activeStatus: document.getElementById('active-status'),
        statusPill: document.getElementById('thread-status-pill'),
        closedBanner: document.getElementById('chat-closed-banner'),
    };

    init();

    async function init() {
        try {
            state.session = await fetchJSON('php/api/session.php');
        } catch (error) {
            console.error(error);
            window.location.href = 'index.html';
            return;
        }

        if (!state.session.authenticated) {
            window.location.href = 'index.html';
            return;
        }

        setupUI();
        registerHandlers();
        if (state.session.role === 'user') {
            await populatePriestSelect();
        }
        loadThreads();
    }

    function setupUI() {
        const { session } = state;

        // Safely handle welcome message
        if (els.welcome && els.welcome.style) {
            els.welcome.style.display = 'inline-block';
        }
        if (els.loginBtn && els.loginBtn.style) {
            els.loginBtn.style.display = 'none';
        }

        // Update text content if elements exist
        if (els.usernameDisplay) els.usernameDisplay.textContent = session.full_name || session.username;
        if (els.userRoleDisplay) els.userRoleDisplay.textContent = session.role === 'priest' ? 'Priest Portal' : 'Penitent Portal';
        if (els.userNameDisplay) els.userNameDisplay.textContent = `Welcome, ${session.full_name || session.username}`;
        
        if (els.roleDescription) {
            els.roleDescription.textContent = session.role === 'priest'
                ? 'Review every confession, validate authenticity, and provide encrypted counsel.'
                : 'Submit your confession and keep track of replies from the clergy.';
        }

        // Feature sections with safe style access
        if (els.confessSection && els.confessSection.style) {
            els.confessSection.style.display = session.role === 'user' ? 'block' : 'none';
        }

        if (els.statsSection && els.statsSection.style) {
            els.statsSection.style.display = session.role === 'priest' ? 'grid' : 'none';
        }
    }

    function registerHandlers() {
        if (els.debugToggle) {
            els.debugToggle.addEventListener('change', () => {
                state.debugMode = els.debugToggle.checked;
                if (state.activeThreadId) {
                    renderActiveThread();
                }
            });
        }

        const deleteBtn = document.getElementById('delete-all-btn');
        if (deleteBtn) {
            if (state.session.role === 'priest') {
                deleteBtn.style.display = 'block';
                deleteBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    if (!confirm('Are you sure you want to delete ALL confessions? This cannot be undone.')) {
                        return;
                    }
                    try {
                        const res = await fetchJSON('php/api/delete_all.php', { method: 'POST' });
                        alert(res.message || 'All confessions deleted.');
                        loadThreads();
                    } catch {
                        alert('Failed to delete confessions.');
                    }
                });
            } else {
                deleteBtn.style.display = 'none';
            }
        }

        if (els.confessForm) {
            els.confessForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(els.confessForm);
                formData.append('recipient_id', (els.priestSelect && els.priestSelect.value) || '');
                try {
                    const response = await fetchJSON('php/api/confessions.php', {
                        method: 'POST',
                        body: formData,
                    });
                    alert(response.message || 'Confession submitted.');
                    els.confessForm.reset();
                    loadThreads(true);
                } catch {
                    alert('Failed to send confession.');
                }
            });
        }

        if (els.refreshBtn) {
            els.refreshBtn.addEventListener('click', () => loadThreads(true));
        }

        if (els.messageForm) {
            els.messageForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!state.activeThreadId) {
                    alert('Select a session to continue.');
                    return;
                }
            const text = els.messageTextarea.value.trim();
            if (!text) {
                alert('Please write a message.');
                return;
            }
            const payload = {
                confession_id: state.activeThreadId,
                message: text,
                resolve: els.resolveCheckbox.checked,
            };
            setComposerDisabled(true);
                try {
                    await fetchJSON('php/api/thread_message.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });
                    els.messageTextarea.value = '';
                    els.resolveCheckbox.checked = false;
                    await loadThreadDetail(state.activeThreadId);
                    await loadThreads();
                } catch (error) {
                    alert((error && error.message) || 'Failed to send message.');
                } finally {
                    setComposerDisabled(false);
                }
            });
        }
    }

    async function populatePriestSelect() {
        try {
            const priests = await fetchJSON('php/api/priests.php');
            els.priestSelect.innerHTML = priests
                .map(priest => `<option value="${priest.id}">${escapeHtml(priest.full_name || priest.username)}</option>`)
                .join('');
        } catch {
            els.priestSelect.innerHTML = '<option value="">Unable to load priests</option>';
        }
    }

    async function loadThreads(force = false) {
        if (state.loadingThreads && !force) return;
        state.loadingThreads = true;
        try {
            const data = await fetchJSON('php/api/confessions.php');
            state.threads = data.threads || [];
            updateStats(data.stats || {});
            renderThreadList();
            if (state.threads.length) {
                const hasActive = state.threads.some(t => t.id === state.activeThreadId);
                if (!hasActive) {
                    state.activeThreadId = null;
                    state.activeThreadMeta = null;
                }
                if (!state.activeThreadId && state.threads.length) {
                    selectThread(state.threads[0].id);
                } else if (state.activeThreadId) {
                    renderActiveThread();
                }
            } else {
                state.activeThreadId = null;
                state.activeThreadMeta = null;
                renderActiveThread();
            }
        } catch (error) {
            console.error(error);
            alert('Unable to load conversations.');
        } finally {
            state.loadingThreads = false;
        }
    }

    function updateStats(stats) {
        if (!els.statsSection) return;
        els.statTotal.textContent = stats.total ?? 0;
        els.statAwaiting.textContent = stats.awaiting ?? 0;
        els.statReplied.textContent = stats.replied ?? 0;
    }

    function renderThreadList() {
        if (!els.threadList) return;
        if (!state.threads.length) {
            els.threadEmpty.style.display = 'block';
            els.threadList.innerHTML = '';
            return;
        }
        els.threadEmpty.style.display = 'none';
        els.threadList.innerHTML = state.threads.map(thread => {
            const statusLabel = thread.resolved
                ? 'Closed'
                : thread.needs_reply
                    ? 'Awaiting priest'
                    : 'Awaiting penitent';
            const statusClass = thread.resolved ? 'status settled' : (thread.needs_reply ? 'status awaiting' : 'status settled');
            const activeClass = thread.id === state.activeThreadId ? 'active' : '';
            return `
                <li class="${thread.needs_reply ? 'has-awaiting' : ''} ${activeClass}" data-thread-id="${thread.id}">
                    <div>
                        <strong>${escapeHtml(thread.subject)}</strong>
                        <div style="font-size:12px; color:#6b5948;">${escapeHtml(thread.partner_name || '')}</div>
                        <small style="color:#8c7348;">${formatTimestamp(thread.last_message && thread.last_message.at)}</small>
                    </div>
                    <div>
                        <span class="${statusClass}">${statusLabel}</span>
                    </div>
                </li>
            `;
        }).join('');

        els.threadList.querySelectorAll('li[data-thread-id]').forEach(li => {
            li.addEventListener('click', () => {
                const id = Number(li.dataset.threadId);
                selectThread(id);
            });
        });
    }

    function selectThread(id) {
        if (!id) return;
        if (state.activeThreadId === id) {
            loadThreadDetail(id);
            return;
        }
        state.activeThreadId = id;
        state.activeThreadMeta = null;
        state.messagesByThread[id] = [];
        highlightActiveThread();
        loadThreadDetail(id);
    }

    async function loadThreadDetail(id) {
        if (!id) return;
        els.chatMessages.innerHTML = '<p class="muted">Loading conversation...</p>';
        try {
            const data = await fetchJSON(`php/api/thread.php?id=${id}`);
            state.messagesByThread[id] = data.messages || [];
            state.activeThreadMeta = data.thread || null;
            renderActiveThread();
        } catch (error) {
            console.error(error);
            els.chatMessages.innerHTML = '<p class="muted">Unable to load this conversation.</p>';
        }
    }

    function renderActiveThread() {
        if (!state.activeThreadId || !state.activeThreadMeta) {
            els.activePartner.textContent = 'Select a session';
            els.activeSubject.textContent = 'No conversation selected';
            els.activeStatus.textContent = 'Choose a subject to start the secure chat.';
            els.statusPill.textContent = 'Idle';
            els.statusPill.className = 'status-pill';
            els.chatMessages.innerHTML = '<p class="muted">No conversation selected.</p>';
            els.messageForm.style.display = 'none';
            els.closedBanner.style.display = 'none';
            return;
        }

        const meta = state.activeThreadMeta;
        els.activePartner.textContent = `${meta.partner_role === 'priest' ? 'Priest' : 'Penitent'} • ${meta.partner_name}`;
        els.activeSubject.textContent = meta.subject;
        els.activeStatus.textContent = meta.status === 'closed'
            ? 'Conversation closed.'
            : meta.status === 'awaiting_priest'
                ? 'Waiting for priest response'
                : 'Waiting for penitent reply';
        setStatusPill(meta.status);

        const messages = state.messagesByThread[state.activeThreadId] || [];
        if (!messages.length) {
            els.chatMessages.innerHTML = '<p class="muted">No messages yet.</p>';
        } else {
            els.chatMessages.innerHTML = messages.map(message => renderMessageBubble(message)).join('');
        }

        if (meta.resolved) {
            els.messageForm.style.display = 'none';
            els.closedBanner.style.display = 'block';
        } else {
            els.messageForm.style.display = 'block';
            els.closedBanner.style.display = 'none';
        }
    }

    function renderMessageBubble(message) {
        const metaLine = `${escapeHtml(message.sender_name)} • ${formatTimestamp(message.created_at)}`;
        const signatureLine = state.debugMode && message.signature_valid !== null
            ? `<div class="bubble-meta">Signature ${message.signature_valid ? 'valid' : 'invalid'}</div>`
            : '';
        return `
            <article class="chat-message ${message.sender_role}">
                <div class="bubble-meta">${metaLine}</div>
                <div class="bubble">${formatMessageText(message.plaintext)}</div>
                ${signatureLine}
            </article>
        `;
    }

    function setStatusPill(status) {
        const base = 'status-pill';
        if (status === 'closed') {
            els.statusPill.className = `${base} closed`;
            els.statusPill.textContent = 'Closed';
        } else if (status === 'awaiting_priest') {
            els.statusPill.className = `${base} awaiting`;
            els.statusPill.textContent = 'Needs priest';
        } else if (status === 'awaiting_penitent') {
            els.statusPill.className = `${base} active`;
            els.statusPill.textContent = 'Needs penitent';
        } else {
            els.statusPill.className = base;
            els.statusPill.textContent = 'Active';
        }
    }

    function highlightActiveThread() {
        if (!els.threadList) return;
        els.threadList.querySelectorAll('li').forEach(li => {
            const id = Number(li.dataset.threadId);
            if (id === state.activeThreadId) {
                li.classList.add('active');
            } else {
                li.classList.remove('active');
            }
        });
    }

    function setComposerDisabled(disabled) {
        if (!els.messageForm) return;
        els.messageTextarea.disabled = disabled;
        els.resolveCheckbox.disabled = disabled;
        const button = els.messageForm.querySelector('button[type="submit"]');
        if (button) {
            button.disabled = disabled;
            button.textContent = disabled ? 'Sending…' : 'Send Secure Message';
        }
    }

    function formatTimestamp(value) {
        if (!value) return '';
        const date = new Date(value.replace(' ', 'T'));
        if (Number.isNaN(date.getTime())) return value;
        return date.toLocaleString();
    }

    function formatMessageText(text) {
        if (!text) return '';
        const safe = escapeHtml(text);
        return safe.replace(/\n/g, '<br>');
    }

    function escapeHtml(text) {
        if (typeof text !== 'string') return '';
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    async function fetchJSON(url, options = {}) {
        const response = await fetch(url, options);
        if (!response.ok) {
            let message = 'Network error';
            try {
                const data = await response.json();
                message = data.message || message;
            } catch (e) {
                // ignore
            }
            throw new Error(message);
        }
        return response.json();
    }
})();
